//! # Noise
//!
//! Contains Gens producing noise and random numbers with different distributions and interpolations.

use crate::core::sync::atomic::AtomicU64;
use crate::numeric_array::NumericArray;
use crate::typenum::{U0, U1};
use crate::{AudioCtx, Gen, GenFlags, ParameterRange, ParameterValue};
use knaster_primitives::{Float, Frame};
use std::marker::PhantomData;

/// Used to seed random number generating Gens to create a deterministic result as long as all Gens are created in the same order from start.
static NEXT_SEED: AtomicU64 = AtomicU64::new(0);

/// Request the next randomness seed. Use this if you are implementing your own [`Gen`] producing
/// randomness. If all [`Gen`]s use deterministic algorithms and are seeded using this function,
/// a graph constructed in the same order will have deterministic randomness.
/// ```
/// # use crate::knaster_core::noise::next_randomness_seed;
/// let rng = fastrand::Rng::with_seed(next_randomness_seed());
/// ```
pub fn next_randomness_seed() -> u64 {
    NEXT_SEED.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
}

/// White noise (fastrand RNG, based on wyrand)
#[derive(Clone, Debug)]
pub struct WhiteNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    _marker: PhantomData<F>,
}
impl<F: Float> WhiteNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            _marker: PhantomData,
        }
    }
}
impl<F: Float> Gen for WhiteNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;

    fn process(
        &mut self,
        ctx: AudioCtx,
        flags: &mut GenFlags,
        input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        [F::new(self.rng.f32() * 2.0 - 1.0)].into()
    }

    fn param_range() -> NumericArray<ParameterRange, Self::Parameters> {
        [].into()
    }

    fn param_apply(&mut self, ctx: AudioCtx, index: usize, value: ParameterValue) {}
}
const PINK_NOISE_OCTAVES: u32 = 9;
/// Pink noise
///
/// Usually outputs in the +-0.75 range and cannot surpass +-1.0
///
/// Computed using the Voss-MacCartney method of stacking white noise in lower and lower octaves.
/// Algorithms from: https://www.firstpr.com.au/dsp/pink-noise/#Filtering
pub struct PinkNoise<F: Copy = f32> {
    white_noises: [F; PINK_NOISE_OCTAVES as usize],
    always_on_white_noise: F,
    counter: u32,
    mask: u32,
    pink: F,
    rng: fastrand::Rng,
}
impl<F: Float> PinkNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            white_noises: [F::ZERO; PINK_NOISE_OCTAVES as usize],
            always_on_white_noise: F::ZERO,
            counter: 1,
            mask: 2_u32.pow(PINK_NOISE_OCTAVES - 1),
            pink: F::ZERO,
            rng,
        }
    }
    fn noise_index(&self) -> u32 {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter.trailing_zeros()
    }

    fn increment_counter(&mut self) {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter = self.counter & (self.mask - 1);
        self.counter = self.counter + 1;
    }

    // TODO: Generate f64 random number when F is f64
    #[allow(missing_docs)]
    pub fn process_sample(&mut self) -> F {
        let index = self.noise_index() as usize;
        assert!(index < PINK_NOISE_OCTAVES as usize);

        self.pink = self.pink - self.white_noises[index];
        self.white_noises[index] = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink = self.pink + self.white_noises[index];

        self.pink = self.pink - self.always_on_white_noise;
        self.always_on_white_noise = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink = self.pink + self.always_on_white_noise;

        self.increment_counter();

        self.pink / (F::from(PINK_NOISE_OCTAVES).unwrap() + F::ONE)
    }
}
impl<F: Float> Gen for PinkNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;

    fn process(
        &mut self,
        ctx: AudioCtx,
        flags: &mut GenFlags,
        input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        [self.process_sample()].into()
    }

    fn param_range() -> NumericArray<ParameterRange, Self::Parameters> {
        [].into()
    }
    fn param_apply(&mut self, ctx: AudioCtx, index: usize, value: ParameterValue) {}
}

/// Brown noise (also known as red noise)
///
/// Brown noise is generated by integrating white noise.
/// This implementation uses a simple integration of white noise samples with a small step size,
/// and clamps the output to prevent it from exceeding the [-1.0, 1.0] range.
pub struct BrownNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    last_output: F,
}

impl<F: Float> BrownNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            last_output: F::ZERO,
        }
    }
}

impl<F: Float> Gen for BrownNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;
    fn process(
        &mut self,
        ctx: AudioCtx,
        flags: &mut GenFlags,
        input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        let white = F::new(self.rng.f32() * 2.0 - 1.0);
        // Adjust the coefficient to control the step size
        self.last_output += white * F::new(0.1);
        // Clamp to [-1.0, 1.0] to prevent output from exceeding the range
        self.last_output = self.last_output.clamp(-F::ONE, F::ONE);
        [self.last_output].into()
    }

    fn param_range() -> NumericArray<ParameterRange, Self::Parameters> {
        [].into()
    }

    fn param_apply(&mut self, ctx: AudioCtx, index: usize, value: ParameterValue) {}
}
