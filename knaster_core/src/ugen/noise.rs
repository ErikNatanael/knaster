//! # Noise
//!
//! Contains UGens producing noise and random numbers with different distributions and interpolations.

use crate::core::marker::PhantomData;
use crate::core::sync::atomic::AtomicU64;
use crate::numeric_array::NumericArray;
use crate::typenum::{U0, U1};
use crate::{AudioCtx, ParameterHint, ParameterValue, UGen, UGenFlags};
use knaster_primitives::{Float, Frame};

/// Used to seed random number generating Gens to create a deterministic result as long as all Gens are created in the same order from start.
static NEXT_SEED: AtomicU64 = AtomicU64::new(0);

/// Request the next randomness seed. Use this if you are implementing your own [`UGen`] producing
/// randomness. If all [`UGen`]s use deterministic algorithms and are seeded using this function,
/// a graph constructed in the same order will have deterministic randomness.
/// ```
/// # use crate::knaster_core::noise::next_randomness_seed;
/// let rng = fastrand::Rng::with_seed(next_randomness_seed());
/// ```
pub fn next_randomness_seed() -> u64 {
    NEXT_SEED.fetch_add(1, crate::core::sync::atomic::Ordering::SeqCst)
}

/// White noise (fastrand RNG, based on wyrand)
#[derive(Clone, Debug)]
pub struct WhiteNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    _marker: PhantomData<F>,
}
impl<F: Float> WhiteNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            _marker: PhantomData,
        }
    }
}

impl<F: Float> Default for WhiteNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}
impl<F: Float> UGen for WhiteNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;

    fn process(
        &mut self,
        _ctx: &mut AudioCtx,
        _flags: &mut UGenFlags,
        _input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        [F::new(self.rng.f32() * 2.0 - 1.0)].into()
    }

    fn param_hints() -> NumericArray<ParameterHint, Self::Parameters> {
        [].into()
    }

    fn param_apply(&mut self, _ctx: &mut AudioCtx, _index: usize, _value: ParameterValue) {}
}
const PINK_NOISE_OCTAVES: u32 = 9;
/// Pink noise
///
/// Usually outputs in the +-0.75 range and cannot surpass +-1.0
///
/// Computed using the Voss-MacCartney method of stacking white noise in lower and lower octaves.
/// Algorithms from: https://www.firstpr.com.au/dsp/pink-noise/#Filtering
pub struct PinkNoise<F: Copy = f32> {
    white_noises: [F; PINK_NOISE_OCTAVES as usize],
    always_on_white_noise: F,
    counter: u32,
    mask: u32,
    pink: F,
    rng: fastrand::Rng,
}
impl<F: Float> PinkNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            white_noises: [F::ZERO; PINK_NOISE_OCTAVES as usize],
            always_on_white_noise: F::ZERO,
            counter: 1,
            mask: 2_u32.pow(PINK_NOISE_OCTAVES - 1),
            pink: F::ZERO,
            rng,
        }
    }
    fn noise_index(&self) -> u32 {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter.trailing_zeros()
    }

    fn increment_counter(&mut self) {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter &= self.mask - 1;
        self.counter += 1;
    }

    // TODO: Generate f64 random number when F is f64
    #[allow(missing_docs)]
    pub fn process_sample(&mut self) -> F {
        let index = self.noise_index() as usize;
        assert!(index < PINK_NOISE_OCTAVES as usize);

        self.pink -= self.white_noises[index];
        self.white_noises[index] = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink += self.white_noises[index];

        self.pink -= self.always_on_white_noise;
        self.always_on_white_noise = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink += self.always_on_white_noise;

        self.increment_counter();

        self.pink / (F::from(PINK_NOISE_OCTAVES).unwrap() + F::ONE)
    }
}

impl<F: Float> Default for PinkNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}
impl<F: Float> UGen for PinkNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;

    fn process(
        &mut self,
        _ctx: &mut AudioCtx,
        _flags: &mut UGenFlags,
        _input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        [self.process_sample()].into()
    }

    fn param_hints() -> NumericArray<ParameterHint, Self::Parameters> {
        [].into()
    }
    fn param_apply(&mut self, _ctx: &mut AudioCtx, _index: usize, _value: ParameterValue) {}
}

/// Brown noise (also known as red noise)
///
/// Brown noise is generated by integrating white noise.
/// This implementation uses a simple integration of white noise samples with a small step size,
/// and clamps the output to prevent it from exceeding the [-1.0, 1.0] range.
pub struct BrownNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    last_output: F,
}

impl<F: Float> BrownNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            last_output: F::ZERO,
        }
    }
}

impl<F: Float> Default for BrownNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}

impl<F: Float> UGen for BrownNoise<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U0;
    fn process(
        &mut self,
        _ctx: &mut AudioCtx,
        _flags: &mut UGenFlags,
        _input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        let white = F::new(self.rng.f32() * 2.0 - 1.0);
        // Adjust the coefficient to control the step size
        self.last_output += white * F::new(0.1);
        // Clamp to [-1.0, 1.0] to prevent output from exceeding the range
        self.last_output = self.last_output.clamp(-F::ONE, F::ONE);
        [self.last_output].into()
    }

    fn param_hints() -> NumericArray<ParameterHint, Self::Parameters> {
        [].into()
    }

    fn param_apply(&mut self, _ctx: &mut AudioCtx, _index: usize, _value: ParameterValue) {}
}
/// Random numbers 0..1 with linear interpolation with new values at some frequency. Freq is sampled at control rate only.
pub struct RandomLin<F: Copy = f32> {
    rng: fastrand::Rng,
    current_value: F,
    current_change_width: F,
    // when phase reaches 1 we choose a new value
    phase: F,
    phase_step: F,
    freq_to_phase_inc: F,
}

impl<F: Float> RandomLin<F> {
    /// Create a new RandomLin, seeding it from the global atomic seed.
    pub fn new(freq: F) -> Self {
        let mut rng = fastrand::Rng::with_seed(next_randomness_seed() * 94 + 53);
        Self {
            current_value: F::new(rng.f32()),
            phase: F::ZERO,
            rng,
            freq_to_phase_inc: F::ZERO,
            current_change_width: F::ZERO,
            phase_step: freq,
        }
    }

    #[inline]
    fn new_value(&mut self) {
        let old_target = self.current_value + self.current_change_width;
        let new = F::new(self.rng.f32());
        self.current_value = old_target;
        self.current_change_width = new - old_target;
        self.phase = F::new(0.0);
    }
}

impl<F: Float> UGen for RandomLin<F> {
    type Sample = F;
    type Inputs = U0;
    type Outputs = U1;
    type Parameters = U1;

    fn init(&mut self, sample_rate: u32, block_size: usize) {
        self.freq_to_phase_inc = F::ONE / F::from(sample_rate).unwrap();
        // freq is stored in phase_step until init
        self.phase_step *= self.freq_to_phase_inc;
        self.new_value();
    }
    fn process(
        &mut self,
        _ctx: &mut AudioCtx,
        _flags: &mut UGenFlags,
        _input: Frame<Self::Sample, Self::Inputs>,
    ) -> Frame<Self::Sample, Self::Outputs> {
        let out = self.current_value + self.phase * self.current_change_width;
        self.phase += self.phase_step;

        if self.phase >= F::ONE {
            self.new_value();
        }
        [out].into()
    }

    fn param_hints() -> NumericArray<ParameterHint, Self::Parameters> {
        [ParameterHint::positive_infinite_float()].into()
    }
    fn param_descriptions() -> NumericArray<&'static str, Self::Parameters> {
        ["freq"].into()
    }

    fn param_apply(&mut self, _ctx: &mut AudioCtx, index: usize, value: ParameterValue) {
        match index {
            0 => {
                if self.freq_to_phase_inc == F::ZERO {
                    // freq is stored in phase_step until init
                    self.phase_step = value.f().unwrap();
                } else {
                    self.phase_step = value.f::<F>().unwrap() * self.freq_to_phase_inc;
                }
            }
            _ => {}
        }
    }
}
