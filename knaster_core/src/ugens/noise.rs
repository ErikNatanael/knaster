//! # Noise
//!
//! Contains UGens producing noise and random numbers with different distributions and interpolations.

use crate::core::marker::PhantomData;
use crate::core::sync::atomic::AtomicU64;
use crate::{AudioCtx, PFloat, UGenFlags};
use knaster_primitives::Float;

/// Used to seed random number generating Gens to create a deterministic result as long as all Gens are created in the same order from start.
static NEXT_SEED: AtomicU64 = AtomicU64::new(0);

/// Request the next randomness seed. Use this if you are implementing your own [`UGen`] producing
/// randomness. If all [`UGen`]s use deterministic algorithms and are seeded using this function,
/// a graph constructed in the same order will have deterministic randomness.
/// ```
/// # use crate::knaster_core::noise::next_randomness_seed;
/// let rng = fastrand::Rng::with_seed(next_randomness_seed());
/// ```
pub fn next_randomness_seed() -> u64 {
    NEXT_SEED.fetch_add(1, crate::core::sync::atomic::Ordering::SeqCst)
}

/// White noise (fastrand RNG, based on wyrand)
#[derive(Clone, Debug)]
pub struct WhiteNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    _marker: PhantomData<F>,
}
#[knaster_macros::impl_ugen]
impl<F: Float> WhiteNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            _marker: PhantomData,
        }
    }
    fn process(&mut self) -> [F; 1] {
        [F::new(self.rng.f32() * 2.0 - 1.0)]
    }
}

impl<F: Float> Default for WhiteNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}
const PINK_NOISE_OCTAVES: u32 = 9;
/// Pink noise
///
/// Usually outputs in the +-0.75 range and cannot surpass +-1.0
///
/// Computed using the Voss-MacCartney method of stacking white noise in lower and lower octaves.
/// Algorithms from: https://www.firstpr.com.au/dsp/pink-noise/#Filtering
pub struct PinkNoise<F: Copy = f32> {
    white_noises: [F; PINK_NOISE_OCTAVES as usize],
    always_on_white_noise: F,
    counter: u32,
    mask: u32,
    pink: F,
    rng: fastrand::Rng,
}
#[knaster_macros::impl_ugen]
impl<F: Float> PinkNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            white_noises: [F::ZERO; PINK_NOISE_OCTAVES as usize],
            always_on_white_noise: F::ZERO,
            counter: 1,
            mask: 2_u32.pow(PINK_NOISE_OCTAVES - 1),
            pink: F::ZERO,
            rng,
        }
    }
    fn noise_index(&self) -> u32 {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter.trailing_zeros()
    }

    fn increment_counter(&mut self) {
        assert!(self.counter > 0);
        assert!(self.counter <= self.mask);

        self.counter &= self.mask - 1;
        self.counter += 1;
    }

    // TODO: Generate f64 random number when F is f64
    #[allow(missing_docs)]
    pub fn process(&mut self) -> [F; 1] {
        let index = self.noise_index() as usize;
        assert!(index < PINK_NOISE_OCTAVES as usize);

        self.pink -= self.white_noises[index];
        self.white_noises[index] = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink += self.white_noises[index];

        self.pink -= self.always_on_white_noise;
        self.always_on_white_noise = F::new(self.rng.f32() * 2.0 - 1.0);
        self.pink += self.always_on_white_noise;

        self.increment_counter();

        [self.pink / (F::from(PINK_NOISE_OCTAVES).unwrap() + F::ONE)]
    }
}

impl<F: Float> Default for PinkNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}

/// Brown noise (also known as red noise)
///
/// Brown noise is generated by integrating white noise.
/// This implementation uses a simple integration of white noise samples with a small step size,
/// and clamps the output to prevent it from exceeding the [-1.0, 1.0] range.
pub struct BrownNoise<F: Copy = f32> {
    rng: fastrand::Rng,
    last_output: F,
}

#[knaster_macros::impl_ugen]
impl<F: Float> BrownNoise<F> {
    #[allow(missing_docs)]
    pub fn new() -> Self {
        let rng = fastrand::Rng::with_seed(next_randomness_seed());
        Self {
            rng,
            last_output: F::ZERO,
        }
    }

    /// Produce one frame of brown noise
    pub fn process(&mut self) -> [F; 1] {
        let white = F::new(self.rng.f32() * 2.0 - 1.0);
        // Adjust the coefficient to control the step size
        self.last_output += white * F::new(0.1);
        // Clamp to [-1.0, 1.0] to prevent output from exceeding the range
        self.last_output = self.last_output.clamp(-F::ONE, F::ONE);
        [self.last_output]
    }
}

impl<F: Float> Default for BrownNoise<F> {
    fn default() -> Self {
        Self::new()
    }
}

/// Random numbers 0..1 with linear interpolation with new values at some frequency. Freq is sampled at control rate only.
pub struct RandomLin<F: Copy = f32> {
    rng: fastrand::Rng,
    current_value: F,
    current_change_width: F,
    // when phase reaches 1 we choose a new value
    phase: F,
    phase_step: F,
    freq_to_phase_inc: F,
}

#[knaster_macros::impl_ugen]
impl<F: Float> RandomLin<F> {
    /// Create a new RandomLin, seeding it from the global atomic seed.
    pub fn new(freq: F) -> Self {
        let mut rng = fastrand::Rng::with_seed(next_randomness_seed() * 94 + 53);
        Self {
            current_value: F::new(rng.f32()),
            phase: F::ZERO,
            rng,
            freq_to_phase_inc: F::ZERO,
            current_change_width: F::ZERO,
            phase_step: freq,
        }
    }
    #[param]
    fn test(&mut self, f: F, ctx: &mut AudioCtx) {}

    #[inline]
    fn new_value(&mut self) {
        let old_target = self.current_value + self.current_change_width;
        let new = F::new(self.rng.f32());
        self.current_value = old_target;
        self.current_change_width = new - old_target;
        self.phase = F::new(0.0);
    }
    fn init(&mut self, sample_rate: u32, _block_size: usize) {
        self.freq_to_phase_inc = F::ONE / F::from(sample_rate).unwrap();
        // freq is stored in phase_step until init
        self.phase_step *= self.freq_to_phase_inc;
        self.new_value();
    }
    fn process(&mut self, _ctx: &mut AudioCtx, _flags: &mut UGenFlags) -> [F; 1] {
        let out = self.current_value + self.phase * self.current_change_width;
        self.phase += self.phase_step;

        if self.phase >= F::ONE {
            self.new_value();
        }
        [out]
    }
    /// Set the frequency of producing new random numbers
    #[param]
    pub fn freq(&mut self, value: PFloat) {
        if self.freq_to_phase_inc == F::ZERO {
            // freq is stored in phase_step until init
            self.phase_step = F::new(value);
        } else {
            self.phase_step = F::new(value) * self.freq_to_phase_inc;
        }
    }
}
